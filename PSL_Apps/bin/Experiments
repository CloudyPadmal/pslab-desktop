#!/usr/bin/python
"""  ###################################################################################################################
Entry point for PSLab python desktop application. This will connect to a PSLab device and display a list of available 
instruments to work with. If a device is not connected, window will be reddish with instruments disabled
"""  ###################################################################################################################
from __future__ import print_function

import functools
import importlib
import inspect
import os
import pkgutil
import sys
from argparse import ArgumentParser

import pkg_resources
# PSLab library imports ################################################################################################
from PSL import sciencelab
# PyQt5 imports ########################################################################################################
from PyQt5 import QtCore
from PyQt5 import QtGui
from PyQt5.QtWidgets import QApplication as QApp
from PyQt5.QtWidgets import QDesktopWidget as QDesktop
from PyQt5.QtWidgets import QFileDialog as QFileDialog
from PyQt5.QtWidgets import QFrame as QFrame
from PyQt5.QtWidgets import QLabel as QLabel
from PyQt5.QtWidgets import QMainWindow as QWindow
from PyQt5.QtWidgets import QMessageBox as QMessage
from PyQt5.QtWidgets import QProgressBar as QProgress
from PyQt5.QtWidgets import QSplashScreen as QSplash

from PSL_Apps.templates import auto_single_col_exp as UI
from PSL_Apps.utilitiesClass import utilitiesClass

# Setting up PORT arguments ############################################################################################
# In case if a user wants to add multiple devices, connect using a port name
parser = ArgumentParser()
parser.add_argument("-P", dest="PortName", help="If there are multiple devices, provide the port name; e.g /dev/ttyACM0"
                    , metavar="PORT_NAME")
args = parser.parse_args()
# String parsing for UTF-8 #############################################################################################
_fromUtf8 = lambda s: s
TEST_MODE = False


########################################################################################################################
class PSLabDesktop(QWindow, UI.Ui_MainWindow, utilitiesClass):
    """  ###############################################################################################################
    Main UI class for PSLab desktop app. Starts with a splash screen trying to connect to a PSLab device and displays 
    the results by making screen color either red or blue; values fetched from stylesheets
    """  ###############################################################################################################

    def __init__(self, parent=None, **kwargs):
        super(PSLabDesktop, self).__init__()
        self.eventHandler = kwargs.get('app', None)
        # Print where we have imported the modules from for debugging purposes
        if TEST_MODE: self.printModuleLocations()

        # Display splash screen to start configure libraries and PSLab device
        self.showSplash()
        self.updateSplash(10, 'Setting up UI ...')  # 10
        # Initiate UI widgets
        self.setupUi(self)
        self.setWindowIcon(QtGui.QIcon('pslab_logo.png'))
        self.styleText = pkg_resources.resource_string('PSL_Apps', "stylesheets/overall.css").decode("utf-8")
        self.setStyleSheet(self.styleText)
        self.updateSplash(10, 'Fetching libraries ...')  # 20
        # Setup settings for button layouts to lay instrument icons
        self.row = 0
        self.col = 0
        self.colLimit = 3
        self.statusLabel = QLabel()
        self.statusBar().addWidget(self.statusLabel)

        """  ###########################################################################################################
        Starting device connection process
        """  ###########################################################################################################
        self.updateSplash(10, 'Searching for a PSLab Device ...')  # 30
        if args.PortName:
            # Not using connect method because it returns None if not connected
            self.I = sciencelab.ScienceLab(port=args.PortName)
        else:
            # I need to pass interfacing methods to various widgets regardless
            self.I = sciencelab.ScienceLab(verbose=False)

        self.setWindowTitle('PSLab Desktop App - V2.0')
        self.hexid = ''
        try:
            if not self.I.connected:
                # Display an error dialog with the probable cause
                if len(self.I.H.occupiedPorts):
                    self.display_dialog(QMessage.Warning, "Connection Error", "Cannot find a PSLab device", \
                        details="Software already running for ports: %s" % list(self.I.H.occupiedPorts), information=\
                        "We have detected a PSLab device")
                else:
                    self.display_dialog(QMessage.Warning, "Connection Error", "Cannot find a PSLab device", \
                        details="Make sure that the PSLab device is connected and status LEDs are ON")
                
                # Make the window looks reddish to indicate error
                self.styleText = pkg_resources.resource_string('PSL_Apps',
                                                               "stylesheets/overall_disconnected.css").decode("utf-8")
                self.setStyleSheet(self.styleText)
                self.showStatusBar('Error: PSLab device not connected')
            else:
                # Display device ID at the status bar
                self.hexid = hex(self.I.device_id() & 0xFFFF)
                self.showStatusBar(self.I.generic_name + ': ' + self.hexid)

        except:
            self.updateSplash(30, 'Connection Error ...')  # 60
            self.styleText = pkg_resources.resource_string('PSL_Apps',
                                                           "stylesheets/overall_disconnected.css").decode("utf-8")
            self.setStyleSheet(self.styleText)

        #################################   POPULATE ADVANCED CONTROLS TAB  ##################################
        self.ExperimentLayout.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)
        self.WidgetLayout.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)
        self.advancedControlsLayout.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)
        # Widgets related to power supplies PV1,PVS2,PV3,PCS
        self.supplySection = self.supplyWidget(self.I)
        self.advancedControlsLayout.addWidget(self.supplySection)

        # Widgets related to voltmeters CH1,CH2,CH3,SEN,CAP,AN8
        self.voltSection = self.voltWidget(self.I)
        self.advancedControlsLayout.addWidget(self.voltSection)

        # Widgets related to Analog Waveform generators
        self.sineSection = self.sineWidget(self.I)
        self.advancedControlsLayout.addWidget(self.sineSection)
        # Widgets related to Digital Waveform generators
        self.pwmSection = self.pwmWidget(self.I)
        self.advancedControlsLayout.addWidget(self.pwmSection)
        self.advancedControlsLayout.addWidget(self.setStateIcon(I=self.I))

        """  ###########################################################################################################
        Populating Icons in the "Experiments" section
        """  ###########################################################################################################
        # We may need to change this directory to support different OSs
        sys.path.append('/usr/share/pslab')
        self.subSectionList = []
        self.subSectionPaths = []
        # Load sections in two milliseconds with GUI as bask package
        self.tmpTimer = QtCore.QTimer()
        self.tmpTimer.singleShot(2, functools.partial(self.loadSectionList,
                                                      'PSL_Resources.GUI'))

        """  ###########################################################################################################
        Populating Icons in the "Controls" section
        """  ###########################################################################################################
        row = 0
        col = 0
        colLimit = 3
        self.funcs = []
        autogenControls = []
        self.lay_control_widgets()

        self.menu_entries = []
        self.menu_group = None
        """  ###########################################################################################################
        Timer to detect device connection
        """  ###########################################################################################################
        # A list of USB ports detected by ScienceLab
        self.portList = []
        self.timer = QtCore.QTimer()
        self.timer.timeout.connect(self.locateDevices)
        self.timer.start(500)
        self.updateSplash(30, 'Almost done...')  # 90
        """  ###########################################################################################################
        Window placement at the center of the screen
        """  ###########################################################################################################
        frameDimensions = self.frameGeometry()
        windowCenterPoint = QDesktop().availableGeometry().center()
        frameDimensions.moveCenter(windowCenterPoint)
        self.move(frameDimensions.topLeft())
        # Clear running app instance as there is none running at the beginning
        self.runningApp = None

    def lay_control_widgets(self):
        """  ###########################################################################################################
        Setup the layout for control widgets with relevant labels and parameters
        """  ###########################################################################################################
        params = {'TITLE': 'Wave 1', 'MIN': 1, 'MAX': 5000, 'FUNC': self.I.set_w1, 'TYPE': 'dial2', 'UNITS': 'Hz',
        'TOOLTIP': 'Frequency of waveform generator #1', 'LINK': self.updateWAVE1_FREQ}
        self.WidgetLayout.addWidget(self.dialAndDoubleSpinIcon(**params), 0, 0)
        params = {'TITLE': 'Wave 2', 'MIN': 1, 'MAX': 5000, 'FUNC': self.I.set_w2, 'TYPE': 'dial2', 'UNITS': 'Hz',
        'TOOLTIP': 'Frequency of waveform generator #2', 'LINK': self.updateWAVE2_FREQ}
        self.WidgetLayout.addWidget(self.dialAndDoubleSpinIcon(**params), 0, 1)
        params = {'TITLE': 'Square 1', 'MIN': 0, 'MAX': 50000, 'FUNC': self.modifiedSqr1, 'TYPE': 'dial', 'UNITS': 'Hz',
        'TOOLTIP': 'Frequency of square wave generator #1\n0 for switched off, Max for On state'}
        self.WidgetLayout.addWidget(self.dialIcon(**params), 0, 2)
        ###############################################################################################################
        fn = functools.partial(self.I.DAC.__setRawVoltage__, 'PV1')
        params = {'TITLE': 'PV1', 'MIN': 0, 'MAX': 4095, 'FUNC': fn, 'TYPE': 'dial', 'UNITS': 'V',
        'TOOLTIP': 'Programmable Voltage Source ', 'LINK': self.updatePV1_LABEL}
        self.WidgetLayout.addWidget(self.dialIcon(**params), 1, 0)
        tmpfunc = functools.partial(self.I.DAC.__setRawVoltage__, 'PV2')
        params = {'TITLE': 'PV2', 'MIN': 0, 'MAX': 4095, 'FUNC': tmpfunc, 'TYPE': 'dial', 'UNITS': 'V',
        'TOOLTIP': 'Programmable Voltage Source ', 'LINK': self.updatePV2_LABEL}
        self.WidgetLayout.addWidget(self.dialIcon(**params), 1, 1)
        tmpfunc = functools.partial(self.I.DAC.__setRawVoltage__, 'PV3')
        params = {'TITLE': 'PV3', 'MIN': 0, 'MAX': 4095, 'FUNC': tmpfunc, 'TYPE': 'dial', 'UNITS': 'V',
        'TOOLTIP': 'Programmable Voltage Source ', 'LINK': self.updatePV3_LABEL}
        self.WidgetLayout.addWidget(self.dialIcon(**params), 1, 2)
        ###############################################################################################################
        tmpfunc = lambda x: self.I.DAC.__setRawVoltage__('PCS', 4095 - x)
        params = {'TITLE': 'PCS', 'MIN': 20, 'MAX': 2000, 'FUNC': tmpfunc, 'TYPE': 'dial', 'UNITS': 'A',
        'TOOLTIP': 'Programmable Current Source\nLoad must not exceed 1KOhm ', 'LINK': self.updatePCS_LABEL}
        self.WidgetLayout.addWidget(self.dialIcon(**params), 2, 1)
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Sunken)
        self.WidgetLayout.addWidget(line, 3, 0, 1, 3)
        ###############################################################################################################
        params = {'TITLE': 'CAPACITANCE', 'FUNC': self.I.get_capacitance, 'TYPE': 'button', 'UNITS': 'F',
        'TOOLTIP': 'Read Capacitance connected to CAP input '}
        self.WidgetLayout.addWidget(self.buttonIcon(**params), 4, 0)
        params = {'TITLE': 'RESISTANCE', 'FUNC': self.I.get_resistance, 'TYPE': 'button', 'UNITS': u"\u03A9",
        'TOOLTIP': 'Read Resistance connected to SEN input '}
        self.WidgetLayout.addWidget(self.buttonIcon(**params), 4, 1)
        tmpfunc = functools.partial(self.I.get_average_voltage, samples=100)
        params = {'TITLE': 'VOLTMETER', 'FUNC': tmpfunc, 'TYPE': 'selectButton', 'UNITS': 'V', 'TOOLTIP': 'Voltmeter',
        'OPTIONS': self.I.allAnalogChannels}
        self.WidgetLayout.addWidget(self.selectAndButtonIcon(**params), 4, 2)
        ###############################################################################################################
        params = {'TITLE': 'Low Frequency', 'FUNC': self.I.get_freq, 'TYPE': 'selectButton', 'UNITS': 'Hz',
        'TOOLTIP': 'Measure Frequency. Minimum 40Hz', 'OPTIONS': self.I.allDigitalChannels}
        self.WidgetLayout.addWidget(self.selectAndButtonIcon(**params), 5, 0)
        params = {'TITLE': 'High Frequency', 'FUNC': self.I.get_high_freq, 'TYPE': 'selectButton', 'UNITS': 'Hz',
        'TOOLTIP': 'Measure Frequencies over 1MHz with 10Hz resolution', 'OPTIONS': self.I.allDigitalChannels}
        self.WidgetLayout.addWidget(self.selectAndButtonIcon(**params), 5, 1)
        self.WidgetLayout.addWidget(self.pulseCounterIcon(self.I), 5, 2)
        ###############################################################################################################
        
    def showStatusBar(self, statusMsg):
        """  ###########################################################################################################
        Display status at the bottom of the window
        """  ###########################################################################################################
        self.statusLabel.setText(statusMsg)

    def printModuleLocations(self):
        """  ###########################################################################################################
        Display module directories of used packages for debugging purposes
        """  ###########################################################################################################
        print("Modules used in application were imported from directories::::")
        print("ScienceLab: " + repr(inspect.getmodule(sciencelab)))
        print("QtCore: " + repr(inspect.getmodule(QtCore)))
        print("utilitiesClass: " + repr(inspect.getmodule(utilitiesClass)))
        print("UI: " + repr(inspect.getmodule(UI)))
        print("==============================================================")

    def showSplash(self):
        """  ###########################################################################################################
        Prepare and display a splash screen until initiation is complete
        """  ###########################################################################################################
        splash_pix = QtGui.QPixmap(pkg_resources.resource_filename('PSL_Apps.stylesheets', "splash.png"))
        self.splash = QSplash(splash_pix)
        # Create a progress bar at the bottom of Splash screen
        self.progressBar = QProgress(self.splash)
        self.progressBar.move(0, self.splash.height() - 20)
        self.splashMsg = QLabel(self.splash)
        self.splashMsg.setStyleSheet("font-weight:bold; color:white")
        self.progressBar.resize(self.splash.width(), 20)
        self.splashMsg.setText('Starting PSLab Desktop App ...')
        self.splashMsg.resize(self.progressBar.width(), 20)
        self.splashMsg.move(0, self.splash.height() - 20)
        css = pkg_resources.resource_string('PSL_Apps', "stylesheets/splash.css").decode("utf-8")
        if css:
            self.splash.setStyleSheet(css)
        self.splash.setMask(splash_pix.mask())
        self.splash.show()

    def updateSplash(self, x, txt=''):
        """  ###########################################################################################################
        Update the progress and text in splash window
        """  ###########################################################################################################
        self.progressBar.setValue(self.progressBar.value() + x)
        if (len(txt)): self.splashMsg.setText('  ' + txt)
        self.eventHandler.processEvents()
        self.splash.repaint()

    def modifiedSqr1(self, val):
        """  ###########################################################################################################
        """  ###########################################################################################################
        if val < 4:
            self.I.set_state(SQR1=0)
            return 'LOW'
        elif val == 50000:
            self.I.set_state(SQR1=1)
            return 'HIGH'
        else:
            v = self.I.sqr1(val)
            return v

    def loadList(self, basepackage):
        """  ###########################################################################################################
        Not in use it seems :/
        """  ###########################################################################################################
        self.funcs = []
        baselib = importlib.import_module(basepackage)
        apps = [name for _, name, _ in pkgutil.iter_modules([os.path.dirname(
            baselib.__file__)])]
        self.colLimit = 1
        for app in apps:
            if (self.col == self.colLimit):
                self.col = 0
                self.row += 1
            fn = functools.partial(self.launchFunc, basepackage + '.' + app)
            self.funcs.append(fn)
            icon = self.experimentListItem(basepackage, app, fn)
            self.ExperimentLayout.addWidget(icon, self.row, self.col)
            icon.mouseHover.connect(self.setHint)
            self.col += 1

        self.col = 0
        self.row += 1
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Sunken)
        self.ExperimentLayout.addWidget(line, self.row, 0, 1, 3)
        self.row += 1

    def importExperimentFolder(self):
        """  ###########################################################################################################
        Opens a file opener window to import Experiment folders similar to the
        ones provided by PSLab Desktop app
        """  ###########################################################################################################
        from os.path import expanduser
        dirname = QFileDialog.getExistingDirectory(self,
                                                   "Load a folder containing Experiments", expanduser("./"),
                                                   QFileDialog.ShowDirsOnly)
        if not dirname: return
        parentPath = os.path.abspath(os.path.join(dirname, os.pardir))
        sys.path.append(parentPath)
        self.loadSubmoduleIcons(dirname.split('/')[-1])
        self.tmpTimer.singleShot(2, self.scrollToEnd)

    def scrollToEnd(self):
        """  ###########################################################################################################
        Go to the bottom of the Experiments section in main window
        """  ###########################################################################################################
        scrollMax = self.ExperimentScrollArea.verticalScrollBar().maximum()
        self.ExperimentScrollArea.verticalScrollBar().setValue(scrollMax)

    def loadSectionList(self, basepackage):
        """  ###########################################################################################################
        Iterate through every resource folder in GUI directory to list sections
        used in PSLab Desktop Experiments section
        """  ###########################################################################################################
        # baselib would be /usr/share/pslab/PSL_Resources/GUI/
        baselib = importlib.import_module(basepackage)
        # Directories under GUI directory
        subdirs = [name for _, name, isDir in pkgutil.iter_modules([os.path.dirname(baselib.__file__)])
                   if isDir == True]
        for sub in subdirs:
            submodule = basepackage + '.' + sub
            sublib = importlib.import_module(submodule)
            self.subSectionList.append(sublib.__dict__.get('title', submodule.split('.')[-1][1:]))
            self.subSectionPaths.append(submodule)
        # Append the main sections to combo box
        self.subSections.addItems(self.subSectionList)

    def changeSubSection(self, sectionIndex):
        """  ###########################################################################################################
        Slot assigned to combo box selecting different sections
        """  ###########################################################################################################
        self.loadParentModuleIcons(self.subSectionPaths[sectionIndex])

    def loadParentModuleIcons(self, basepackage):
        """  ###########################################################################################################
        Load packages in GUI folder under different categories
        Eg: PSL_Resources.GUI.A_TEST_AND_MEASUREMENT
        """  ###########################################################################################################
        # Clears the frame where sub section buttons are to repopulate it
        self.clearExperimentIcons()
        self.funcs = []
        baselib = importlib.import_module(basepackage)
        subdirs = [name for _, name, isDir in pkgutil.iter_modules([os.path.dirname(baselib.__file__)])
                   if isDir == True]
        for sub in subdirs:
            submodule = basepackage + '.' + sub
            self.loadSubmoduleIcons(submodule)

    def loadSubmoduleIcons(self, submodule):
        """  ###########################################################################################################
        Load Python scripts describing each instrument and populate buttons for
        each of those instruments and experiments
        Eg: PSL_Resources.GUI.A_TEST_AND_MEASUREMENT.A_TandM
        """  ###########################################################################################################
        sublib = importlib.import_module(submodule)

        # Set 'Title' extracted from __init__.py file in each module directory
        title = QLabel()
        title.setText(sublib.__dict__.get('title', submodule.split('.')[-1][1:]))
        # Adds a label as a heading. Args will be [row, col, rowSpan, colSpan]
        self.ExperimentLayout.addWidget(title, self.row, 0, 1, self.colLimit)
        # Increment row to move one line below
        self.col = 0
        self.row += 1
        # Add a horizontal bar to separate title with the icons
        line = QFrame()
        line.setFrameShape(QFrame.HLine)
        line.setFrameShadow(QFrame.Sunken)
        self.ExperimentLayout.addWidget(line, self.row, 0, 1, self.colLimit)
        # Increment row to move one line below
        self.col = 0
        self.row += 1

        # Iterate through every app script to generate a button with relevant
        # functions and resources
        appScripts = [name for _, name, isDir in pkgutil.iter_modules([os.path.dirname(sublib.__file__)])
                      if isDir == False]
        for app in appScripts:
            # There will be three buttons for each row
            if (self.col == self.colLimit):
                self.col = 0
                self.row += 1
            # Create a callable for each UI script and append it to a list
            appLocation = submodule + '.' + app
            fn = functools.partial(self.launchFunc, appLocation)
            self.funcs.append(fn)
            # Create an experiment Icon from utilitiesClass and assign actions
            # This 'icon' will extend a QPushButton and fn will be assigned to
            # the connect method
            icon = self.experimentIcon(submodule, app, fn)
            # Add the button to Experiment layout grid
            self.ExperimentLayout.addWidget(icon, self.row, self.col)
            # Connect hintview to mouse hover event
            icon.mouseHover.connect(self.setHint)
            self.col += 1
        # Prepare icons to fed into the next row
        self.col = 0
        self.row += 1

    def clearExperimentIcons(self):
        """  ###########################################################################################################
        Clear the icons in frame before render new ones upon selecting an item
        from Experiment menu
        """  ###########################################################################################################
        while self.ExperimentLayout.count():
            item = self.ExperimentLayout.takeAt(0)
            item.widget().deleteLater()
        self.row = 0
        self.col = 0
        # Reset column limit to 3
        self.colLimit = 3

    def setHint(self, t):
        """  ###########################################################################################################
        Display the content of hint value in each experiment in the hint frame
        """  ###########################################################################################################
        self.hintText.setHtml(t)

    def launchFunc(self, fname):
        """  ###########################################################################################################
        Function opening a new Window with the respected instrument/experiment
        """  ###########################################################################################################
        if self.I.connected:
            try:
                # If there is an app window open, close it before opening a new
                if self.runningApp:
                    self.runningApp.close()
                    self.killAllTimers()
            except Exception as e:
                print(e)
            # Open the python script containing info about the instrument
            appScripts = importlib.import_module(fname)
            appInstance = appScripts.AppWindow(self, I=self.I)
            appInstance.show()
            size = appInstance.geometry()
            appInstance.setGeometry(500, 50, size.width(), size.height())
            self.runningApp = appInstance
            # Activate the help view in main window
            # TODO: Render the help view by fetching correct resource HTML file
            self.tabWidget.setCurrentIndex(1)
        else:
            # Display error message as no device is connected
            self.display_dialog(QMessage.Warning, "Connection Error", "Cannot find a PSLab device", "Make sure that" +
                " the PSLab device is connected and status LEDs are ON")

    def returnToApps(self):
        """  ###########################################################################################################
        Display the main view where instruments and experiments are shown
        """  ###########################################################################################################
        self.tabWidget.setCurrentIndex(0)

    def launchAboutDevice(self):
        """  ###########################################################################################################
        Display a window with details about connected devices. This will be a seperate UI file based on a table view
        """  ###########################################################################################################
        if self.I.connected:
            from PSL_Apps.utilityApps import deviceInfo
            info = deviceInfo.AppWindow(self, I=self.I)
            info.show()
        else:
            # Display error message as no device is connected
            self.display_dialog(QMessage.Warning, "Connection Error", "Cannot find a PSLab device", "Make sure that" +
                " the PSLab device is connected and status LEDs are ON")

    def locateDevices(self):
        """  ###########################################################################################################
        This method will be called periodically to detect if a new device is connected. It will detect a new connection
        by comparing number of USB devices connected with the locally saved device connection list
        """  ###########################################################################################################
        _portList = self.I.H.listPorts()
        menuChanged = False
        if _portList != self.portList:
            menuChanged = True
            self.portList = _portList
            for _port in self.menu_entries:
                self.deviceCombo.removeItem(0)
            self.menu_entries = []
            for _port in _portList:
                self.deviceCombo.addItem(_port)
                self.menu_entries.append(_port)

        # Check for, and handle disconnect event
        if menuChanged:
            if self.I.connected:
                if self.I.H.portname not in self.menu_entries:
                    print(self.menu_entries, self.I.H.portname)
                    self.styleText = pkg_resources.resource_string('PSL_Apps',
                                                                   "stylesheets/overall_disconnected.css").decode(
                        "utf-8")
                    self.setStyleSheet(self.styleText)
                    self.showStatusBar('Error: PSLab device not connected')
                    if self.runningApp:
                        self.runningApp.close()
                    self.I.connected = False

            elif len(self.menu_entries):
                if QMessage.question(self, 'Connection', 'New Device Found. Connect?', QtGui.QMessageBox.No, \
                    QtGui.QMessageBox.Yes) == QMessage.Yes:
                    self.selectDevice()

    def display_dialog(self, icon, title, message, details="", information=""):
        dialog = QMessage()
        dialog.setIcon(icon)
        dialog.setWindowTitle(title)
        dialog.setText(message)
        if len(information) > 0: dialog.setInformativeText(information)
        if len(details) > 0: dialog.setDetailedText(details)
        dialog.exec_()
        return dialog

    def selectDevice(self):
        """  ###########################################################################################################
        """  ###########################################################################################################
        sel = self.deviceCombo.currentText()
        if (not ('ACM' in sel or 'USB' in sel)):
            self.display_dialog(QMessage.Warning, 'Connection Error', 'Cannot find a PSLab device', 
                "Make sure that the PSLab device is connected and status LEDs are ON")
            return
        self.splash.show()
        self.progressBar.setValue(0)
        self.updateSplash(20, 'Reconnecting to %s' % (sel))
        if self.I:
            try:
                self.I.reconnect(port=sel)
            except Exception as e:
                self.updateSplash(30, 'Connection Error!')
                self.styleText = pkg_resources.resource_string('PSL_Apps',
                                                               "stylesheets/overall_disconnected.css").decode("utf-8")
                self.setStyleSheet(self.styleText)

            if not self.I.connected:
                if len(self.I.H.occupiedPorts):
                    diag = QtGui.QMessageBox.about(self, 'Error',
                                                   'Could not find available device.\nSoftware already running for ports: %s' % list(
                                                       self.I.H.occupiedPorts))
                else:
                    diag = QtGui.QMessageBox.about(self, 'Error', 'Could not find available device')
                self.styleText = pkg_resources.resource_string('PSL_Apps',
                                                               "stylesheets/overall_disconnected.css").decode("utf-8")
                self.setStyleSheet(self.styleText)
                self.showStatusBar(self.I.generic_name + ': ' + self.hexid)
            else:
                self.hexid = hex(self.I.device_id() & 0xFFFF)
                self.updateSplash(20, 'Finished Reconnecting...')
                self.display_dialog(QMessage.Information, 'Device Found', 'Reconnected: ' + self.I.H.version_string[1:-1], '')
                self.styleText = pkg_resources.resource_string('PSL_Apps', "stylesheets/overall.css").decode("utf-8")
                self.setStyleSheet(self.styleText)
                self.showStatusBar(self.I.generic_name + ': ' + self.hexid)

        self.splash.close()
        return

    def resetDevice(self):
        """  ###########################################################################################################
        Disconnects and reconnects the device
        """  ###########################################################################################################
        if self.I:
            if self.I.connected:
                self.I.resetHardware()
                self.I.H.fd.close()
                self.I.reconnect()

    def __del__(self):
        """  ###########################################################################################################
        This will be called once the app is being closed. It will close PSLab connections to clean the system
        """  ###########################################################################################################
        try:
            self.I.H.fd.close()
        except:
            pass
        print('Application closed ...')

    ############################Section for correlating control widgets#################################

    def updateWAVE1_FREQ(self, value, units=''):
        self.sineSection.WAVE1_FREQ.setText('%.3f %s ' % (value, units))

    def updateWAVE2_FREQ(self, value, units=''):
        self.sineSection.WAVE2_FREQ.setText('%.3f %s ' % (value, units))

    def updatePV1_LABEL(self, value, units=''):
        self.supplySection.PV1_LABEL.setText('%.3f %s ' % (value, units))

    def updatePV2_LABEL(self, value, units=''):
        self.supplySection.PV2_LABEL.setText('%.3f %s ' % (value, units))

    def updatePV3_LABEL(self, value, units=''):
        self.supplySection.PV3_LABEL.setText('%.3f %s ' % (value, units))

    def updatePCS_LABEL(self, value, units=''):
        self.supplySection.PCS_LABEL.setText('%.3f %s ' % (value, units))

    def measure_dcycle(self):
        inp = self.timing_input.currentText()
        v = self.I.DutyCycle(inp)
        if (v[0] != -1):
            p = 100 * v[1]
        else:
            p = 0
        self.timing_results.setText('Duty Cycle: %f %%' % (p))

    def measure_interval(self):
        t = self.I.MeasureInterval(self.edge1chan.currentText(), self.edge2chan.currentText(),
                                   self.edge1edge.currentText(), self.edge2edge.currentText())
        self.time_interval_label.setText('time: %.2e S' % (t))

    def startRemoteServer(self):
        try:
            from PSL_Apps.utilityApps import remote

            funcs = dir(self.I)
            self.methods = {}
            self.function_list = []
            for a in funcs:
                fn = getattr(self.I, a)
                try:
                    args = inspect.getargspec(fn).args
                except:
                    args = []

                if len(args) > 0:
                    if inspect.ismethod(fn):
                        self.methods[a] = (fn, args)  # list of tuples of all methods in device handler
                        if args[0] == 'self': self.function_list.append([a, args[1:]])

            print(self.function_list)
            print(self.methods)

            self.remote = remote.CherryPyClass(self.function_list, self.methods)
            self.remoteThread = remote.CherryPyThread(self.remote)
            # thread.finished.connect(app.exit)
            self.remoteThread.start()
            QMessage.about(self, 'Server Ready',
                           """Try accessing <span style="font-weight:bold;">localhost:8080/get_voltage('CH1')</span> from your web browser.<br> Do not access the device from multiple locations simultaneously.""")

        except:
            QMessage.about(self, 'Unable to Launch Server', "Is CherryPy web server installed?")


if __name__ == "__main__":
    app = QApp(sys.argv)
    myapp = PSLabDesktop(app=app)
    myapp.show()
    myapp.splash.finish(myapp)
    sys.exit(app.exec_())
